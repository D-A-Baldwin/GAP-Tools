
##############
# A collection of useful tools that are used in some more complicated functions associated
# to working with space groups
##############

RelationsAsLists := function(fpgrp)
	
	# This takes as input a finitely presented group, fpgrp, and outputs the relations 
	# of fpgrp written in a list form so that e.g. the relation g*h*k^2*h^-1 = 1 
	# is stored as [g,h,k,k,h^-1]

	local rels, newrels, word;
	
	rels := RelatorsOfFpGroup(fpgrp);
	newrels := [];
	
	for word in rels do;
		Add(newrels,List(List([1..Length(UnderlyingElement(word))], 
			i -> Subword(UnderlyingElement(word),i,i)),
			i -> ElementOfFpGroup(FamilyObj(fpgrp.1),i)));
	od;
	return newrels;
end;


WordAsList := function(fpgrp, word)
	local newword;
	
	# This takes as input a finitely presented group, fpgrp, and a word written in the
	# generators of fpgrp and outputs the word as a list, similarly to RelationsAsLists.
	
	newword := List(List([1..Length(UnderlyingElement(word))], 
			i -> Subword(UnderlyingElement(word),i,i)),
			i -> ElementOfFpGroup(FamilyObj(fpgrp.1),i));
	return newword;
end;


SpaceGroupGeneratorsStandardForm := function(mat_gens, translations)

	# This takes as input the list generators of a point group (a list n by n matrices 
	# of length k) and a vector system for the point group (a vector of length k*n) 
	# and outputs a list of generators for the space group in 'standard form'. 
	# This means that a generator, g, and its corresponding translation, t, are written as an 
	# (n+1) by (n+1) matrix [[g,t],[0,1]] where g is n by n, t is n by 1 and the last row
	# contains n zeroes and a single 1.

	local dim, last_row, lattice_mat_list, i, lattice_mat, lattice_trans, genslist,
			gen, translation;
	
	dim := DimensionsMat(mat_gens[1])[1];
	
	last_row := NullMat(1,dim)[1];
	Add(last_row,1);
	
	lattice_mat_list := [];;
	for i in [1..dim] do
		lattice_mat := IdentityMat(dim);
		lattice_trans := NullMat(1,dim)[1];
		lattice_trans[i] := 1;
		
		Add(lattice_mat,lattice_trans);
		lattice_mat := TransposedMatMutable(lattice_mat);
		Add(lattice_mat, last_row);
		Add(lattice_mat_list, lattice_mat);
	od;
	
	genslist := [];;

	for i in [1..Length(mat_gens)] do
		gen := ShallowCopy(mat_gens[i]);
		translation := translations{[1+dim*(i-1)..dim+dim*(i-1)]};
		
		Add(gen,translation);
		gen := TransposedMatMutable(gen);
		Add(gen, last_row);
		Add(genslist, gen);
	od;
	
	Append(genslist, lattice_mat_list);
	return genslist;
end;


# The following two functions are useful as they allow one to compute m mod n where
# m is rational. This is not possible with GAP's standard function.

modulofunc := function(m,n)
	local denom, sol;
	denom := DenominatorRat(m);
	sol := (denom*m) mod (n*denom);
	return sol/denom;
end;

modulofunclist := function(mlist, n)
	return List(mlist, i -> modulofunc(i,n));
end;


FixedPointsOfElement := function(elem, trans)
	# This function takes as its input a finite order GL(n,Z) matrix, elem, and a length-n vector, trans, 
	# and outputs the solutions to the equation elem*x + trans = x mod Z^n
	# The output is formatted as [fixed_pts_of_elem, basis_of_inv_subspace] where
	# A fixed point is any element of fixed_pts_of_elem plus arbitrary real linear 
	# combinations of elements in basis_of_inv_subspace
	# For example take the 3x3 example elem := [[0,1,0],[-1,0,0],[0,0,1]] and
	# trans := [0,0,0]
	# The output would be [ [ [ 0, 0, 0 ], [ 1/2, 1/2, 0 ] ], [ [ 0, 0, 1 ] ] ]
	# Since any point of the form [0, 0, x] or [1/2, 1/2, x] is a solution to The
	# above equation.

	local M, DiagG, Qmat, diagonal, nonzerodiagonal, listofranges, possnumerators, i, nums,
	 newnums, row, j, basis_of_inv_subspace, k, lst, fixed_pts_of_elem, Pmat, pt;
	
	M := elem-IdentityMat(Length(elem));
	DiagG := SmithNormalFormIntegerMatTransforms(M).normal;
	Qmat := SmithNormalFormIntegerMatTransforms(M).coltrans;
	Pmat := SmithNormalFormIntegerMatTransforms(M).rowtrans;
	diagonal := DiagonalOfMatrix(DiagG);
	nonzerodiagonal := Filtered(diagonal, elem -> not elem = 0);
	
	pt := -Pmat*trans;
	
	if not Length(nonzerodiagonal) = DimensionsMat(DiagG)[1] and 
		ForAny(pt{[Length(nonzerodiagonal)+1 .. DimensionsMat(DiagG)[1]]}, i->not modulofunc(i,1)=0) then
		
		return [[],[]];
		
	else
		listofranges := [];
		for i in [1..Length(nonzerodiagonal)] do;
			Add(listofranges, [0..nonzerodiagonal[i]-1]);
		od;
		possnumerators := Cartesian(listofranges);
		
		for nums in possnumerators do;
			Append(nums, NullMat(1, Length(diagonal)-Length(nonzerodiagonal))[1]);
		od;
		
		fixed_pts_of_elem := [];
		for newnums in possnumerators do
			row := [];
			for j in [1..Length(newnums)] do
				if not diagonal[j] = 0 then;
					Add(row, (newnums[j]/nonzerodiagonal[j])+(pt[j]/nonzerodiagonal[j]));
				else
					Add(row, 0);
				fi;
			od;
			
			Add(fixed_pts_of_elem, modulofunclist(Qmat*row,1));
		od;
		
		fixed_pts_of_elem := DuplicateFreeList(fixed_pts_of_elem);
		
		basis_of_inv_subspace := [];
		for k in [Length(nonzerodiagonal)+1 .. Length(diagonal)] do
			lst := List([1..Length(diagonal)], i-> 0);
			lst[k] := 1;
			Add(basis_of_inv_subspace, Qmat*lst);
		od;
		return [fixed_pts_of_elem, basis_of_inv_subspace];
	fi;
end;


SpaceGroupTranslationsForAllElems := function(mat_gens, transvec, dim)
	# Note: this function requires the function WordAsList.
	# This function takes as its input the list of generators of a point group and
	# the translations associated to those generators in the space group.
	# mat_gens is a list of k GL(n,Z) matrices and transvec is a vector n*k containing
	# all the translations concatenated.
	# This function is useful as you can find the translation associated to any element 
	# of the point group, not only the generators.
	# The output is [elems, translations_of_elems]. elems is the list of all elements
	# of the point group and translations_of_elems is a list of the same Length
	# containing the corresponding translations.
	
	local point_group, iso_fp, elems_fp, mat_gens_copy, i, gennew, translation, j, row, matgenssq_w_inv,
			genslistnew_w_inv, positions_list, elems_w_translations, translations_of_elems, mat, vec,
			elems;


	point_group := Group(mat_gens);;
	iso_fp := IsomorphismFpGroupByGenerators(point_group, mat_gens);;

	elems := SortedList(Elements(point_group));;
	
	elems_fp := List(List(elems, iso_fp), i -> WordAsList(Range(iso_fp), i));
		
	mat_gens_copy := List(mat_gens, i -> List(i,ShallowCopy));

	for i in [1..Length(mat_gens_copy)] do
		gennew := mat_gens_copy[i];;
		translation := transvec{[1+dim*(i-1)..dim+dim*(i-1)]};;
		for j in [1..Length(gennew)] do
			row := gennew[j];;
			Add(row, translation[j]);
		od;
		vec := NullMat(1,dim)[1];
		Add(vec,1);
		Add(gennew, vec);
	od;

	matgenssq_w_inv := ShallowCopy(mat_gens);;
	Append(matgenssq_w_inv, List(mat_gens, Inverse));
	genslistnew_w_inv := ShallowCopy(mat_gens_copy);;
	Append(genslistnew_w_inv, List(mat_gens_copy, Inverse));


	positions_list := List(elems_fp, i -> List(i, j -> Position(matgenssq_w_inv, 
							InverseGeneralMapping(iso_fp)(j))));;

	elems_w_translations := List(List(positions_list, i -> genslistnew_w_inv{i}), Product);

	for i in [1..Length(elems_w_translations)] do;
		if elems_w_translations[i] = 1 then
			elems_w_translations[i]:=IdentityMat(Length(One(point_group))+1);
		fi;
	od;

	translations_of_elems := [];
	for mat in elems_w_translations do
		Add(translations_of_elems, modulofunclist(Last(TransposedMat(mat)){[1..Length(One(point_group))]},1));
	od;
	
	return [elems, translations_of_elems];
end;
