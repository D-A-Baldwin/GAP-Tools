
InteriorProduct := function(vec_insert, n_form)
	# This function takes as inputs a basis vector and a constant differential form on R^m
	# and computed the interior product.
	# n_form will be a list of components of the form [r, [i,j,k,...]] which stands for
	# r * dx^{ijk...} where i, j, k,... range from 1 to m and dx^{ijk...} means dx^i \wedge dx^j...
	# vec_insert will be a number p from 1 to m representing the p-th basis vector.
	# The output is a differential form in the same format as n_form of degree n-1.
	
	local n_form_new, comp, pos_vec, new_indices;
	
	if not ForAll(n_form, i -> Set(i[2]) = SortedList(i[2])) then
		return "N-form contains repeated indices that will give zero terms, clean it up before inputting";
	else
		
		n_form_new := [];;
		
		for comp in n_form do
			if vec_insert in comp[2] then
				pos_vec := Position(comp[2], vec_insert);;
				
				new_indices := Filtered(comp[2], i-> not i = vec_insert);;
				if pos_vec mod 2 = 1 then
					Add(n_form_new, [comp[1], new_indices]);;
				else
					Add(n_form_new, [-comp[1], new_indices]);;
				fi;
			fi;
		od;
		
		return n_form_new;
	fi;
end;

WedgeProduct := function(n_form, m_form)
	# This function takes two constant differential forms on R^m and computes their wedge
	# product.
	# n_form will be a list of components of the form [r, [i,j,k,...]] which stands for
	# r dx^{ijk...} where i, j, k,... range from 1 to m and dx^{ijk...} means dx^i \wedge dx^j...
	# and similarly for m_form. 
	# The output is a differential form in the same format as n_form and m_form of degree n+m

	local n_plus_m_form, comp_n, comp_m, new_indices, unique_indices, n_plus_m_form_reduced, 
			pos_ind, coeffs, new_indices_sorted, sign;
	
	n_plus_m_form := [];
	
	for comp_n in n_form do
		for comp_m in m_form do
			if not ForAny(comp_n[2], i-> i in comp_m[2]) then
				new_indices := ShallowCopy(comp_n[2]);;
				Append(new_indices, comp_m[2]);;
				
				#sort the list of indices and include the appropriate sign
				new_indices_sorted := SortedList(new_indices);;
				sign := SignPerm(MappingPermListList(new_indices, new_indices_sorted));
				
				Add(n_plus_m_form, [sign * comp_n[1] * comp_m[1], new_indices_sorted]);;
			fi;
		od;
	od;
	
	unique_indices := DuplicateFreeList(List(n_plus_m_form, i-> i[2]));;
	
	n_plus_m_form_reduced := [];;
	
	for ind in unique_indices do
		
		pos_ind := PositionsProperty(n_plus_m_form, i-> i[2] = ind);;
		
		coeffs := List(n_plus_m_form{pos_ind}, i-> i[1]);;
		
		Add(n_plus_m_form_reduced, [Sum(coeffs), ind]);;
	od;
	
	return n_plus_m_form_reduced;
end;
	
	
G2_3form_metric := function(phi)
	# This function takes as input a constant 3-form phi on R^7 which is a list of components of 
	# the form [r, [i,j,k]] which stands for r * dx^{ijk} where i, j, k range 
	# from 1 to 7 and dx^{ijk} means dx^i \wedge dx^j \wedge dx^k.
	# It then computes the standard metric associated to the 3-form using the formula
	# g(u,v) vol = (1/6) * i_u phi \wedge i_v phi \wedge \phi.

	local metric, i, metric_row, j, int_phi1, int_phi2, component;
	
	metric := [];;
	
	for i in [1..7] do
		metric_row := [];;
		for j in [1..7] do
			int_phi1 := InteriorProduct(i, phi);;
			int_phi2 := InteriorProduct(j, phi);;
			
			component := WedgeProduct(WedgeProduct(int_phi1, int_phi2), phi);
			if component = [] then
				Add(metric_row, 0);;
			else
				Add(metric_row, component[1][1]);;
			fi;
		od;
		Add(metric, metric_row);;
	od;
	
	return (1/6)*metric;
end;
